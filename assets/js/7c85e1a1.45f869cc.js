"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[83],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return p}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=u(n),p=i,f=h["".concat(l,".").concat(p)]||h[p]||d[p]||r;return n?a.createElement(f,o(o({ref:t},c),{},{components:n})):a.createElement(f,o({ref:t},c))}));function p(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var u=2;u<r;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5878:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return c},default:function(){return h}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),o=["components"],s={sidebar_position:3},l="Examples",u={unversionedId:"firstSteps/examples",id:"firstSteps/examples",title:"Examples",description:"Custom Firmware",source:"@site/docs/firstSteps/examples.mdx",sourceDirName:"firstSteps",slug:"/firstSteps/examples",permalink:"/CubeTouch/docs/firstSteps/examples",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/firstSteps/examples.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Hardware",permalink:"/CubeTouch/docs/firstSteps/hardware"},next:{title:"Congratulations!",permalink:"/CubeTouch/docs/firstSteps/congratulations"}},c=[{value:"Custom Firmware",id:"custom-firmware",children:[],level:2},{value:"Easy RGB",id:"easy-rgb",children:[],level:2},{value:"Chasse Text",id:"chasse-text",children:[],level:2},{value:"Easy Touch",id:"easy-touch",children:[],level:2},{value:"CDC and Keyboard",id:"cdc-and-keyboard",children:[],level:2},{value:"Custom bootloader",id:"custom-bootloader",children:[],level:2}],d={toc:c};function h(e){var t=e.components,s=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},d,s,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"examples"},"Examples"),(0,r.kt)("h2",{id:"custom-firmware"},"Custom Firmware"),(0,r.kt)("h2",{id:"easy-rgb"},"Easy RGB"),(0,r.kt)("p",null,"A simple example that receives an RGB hex value and displays it.\nSend hex color to the Serial Monitor following this format (R,G,B): #0B4F02"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Check the code \ud83d\udda5"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="EasyRGB/EasyRGB.ino"',title:'"EasyRGB/EasyRGB.ino"'},"/*\n  Easy RGB\n\n  A simple example that receives an RGB hex value and displays it\n  Send hex color following this format (R,G,B): #0B4F02\n  created 2022\n  by Noteolvides for use with CH55xduino\n\n  This example code is in the public domain.\n*/\n\n#include <WS2812.h>\n#include <stdio.h>\n\n#define NUM_LEDS 6\n#define COLOR_PER_LEDS 3\n#define NUM_BYTES (NUM_LEDS * COLOR_PER_LEDS)\n\n__xdata uint8_t ledData[NUM_BYTES];\n__xdata char buffer[8];\nuint8_t bufferPtr = 0;\n\nvoid setAll(uint8_t r, uint8_t g, uint8_t b) {\n  uint8_t i;\n  for (i = 0; i < NUM_LEDS; i++) {\n    set_pixel_for_GRB_LED(ledData, i, r, g, b);\n  }\n  neopixel_show_P3_4(ledData, NUM_BYTES);\n}\n\nuint8_t hex2int(char hex[3]) {\n  uint8_t val = 0;\n  while (*hex) {\n    // get current character then increment\n    char byte = *hex++;\n    // transform hex character to the 4bit equivalent number, using the ascii table indexes\n    if (byte >= '0' && byte <= '9')\n      byte = byte - '0';\n    else if (byte >= 'a' && byte <= 'f')\n      byte = byte - 'a' + 10;\n    else if (byte >= 'A' && byte <= 'F')\n      byte = byte - 'A' + 10;\n    // shift 4 to make space for new digit, and add the 4 bits of the new digit\n    val = (val << 4) | (byte & 0xF);\n  }\n  return val;\n}\n\nvoid setup() {\n  pinMode(34, OUTPUT);  // LEDS PIN\n}\n\nvoid sendColors() {\n  char auxString[3];\n  uint8_t r, g, b;\n  auxString[0] = buffer[1];\n  auxString[1] = buffer[2];\n  auxString[2] = '\\0';\n  r = hex2int(auxString);\n  auxString[0] = buffer[3];\n  auxString[1] = buffer[4];\n  auxString[2] = '\\0';\n  g = hex2int(auxString);\n  auxString[0] = buffer[5];\n  auxString[1] = buffer[6];\n  auxString[2] = '\\0';\n  b = hex2int(auxString);\n  setAll(r, g, b);\n  USBSerial_println_s(\"Done! Just a remainter send hex color following this format : #0B4F02\");\n  USBSerial_flush();\n}\n\nvoid loop() {\n  while (USBSerial_available()) {\n    char serialChar = USBSerial_read();\n    buffer[bufferPtr] = serialChar;\n    bufferPtr++;\n    if (bufferPtr == 7) {\n      buffer[bufferPtr] = '\\0';\n      bufferPtr = 0;\n      sendColors();\n    }\n    if ((serialChar == '\\n') || (serialChar == '\\r')) {\n      buffer[bufferPtr] = '\\0';\n      bufferPtr = 0;\n      break;\n    }\n  }\n}\n\n\n"))),(0,r.kt)("div",{className:"container"},(0,r.kt)("div",{className:"row",style:{alignItems:"center"}},(0,r.kt)("img",{height:"400",style:{objectFit:"contain"},className:"col col--6",src:n(1333).Z,alt:"How To Send RGB CODE"}),(0,r.kt)("img",{height:"450",style:{objectFit:"contain"},className:"col col--6",src:n(8069).Z,alt:"Result Photo"}))),(0,r.kt)("h2",{id:"chasse-text"},"Chasse Text"),(0,r.kt)("p",null,"No configuration, just upload the sketch and enjoy the beautiful colors."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Check the code \ud83d\udda5"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="ChasseTest/ChasseTest.ino"',title:'"ChasseTest/ChasseTest.ino"'},"/*\nEasy RGB\n\nA simple example that no  needs configuration,\njust upload the sketch and enjoy the beautiful colors.\nby Noteolvides for use with CH55xduino\n\nThis example code is in the public domain.\n*/\n\n#include <WS2812.h>\n\n#define NUM_LEDS 6\n#define COLOR_PER_LEDS 3\n#define NUM_BYTES (NUM_LEDS*COLOR_PER_LEDS)\n\n__xdata uint8_t ledData[NUM_BYTES];\n\nvoid setup() {\n  pinMode(34, OUTPUT); //Possible to use other pins.\n}\n\nvoid loop() {\n\n  for (uint8_t i = 0; i < NUM_LEDS; i++) {\n    set_pixel_for_GRB_LED(ledData, i, 50, 0, 0); //Choose the color order depending on the LED you use.\n    neopixel_show_P3_4(ledData, NUM_BYTES); //Possible to use other pins.\n    delay(200);\n  }\n  for (uint8_t i = 0; i < NUM_LEDS; i++) {\n    set_pixel_for_GRB_LED(ledData, i, 0, 50, 0);\n    neopixel_show_P3_4(ledData, NUM_BYTES);\n    delay(200);\n  }\n  for (uint8_t i = 0; i < NUM_LEDS; i++) {\n    set_pixel_for_GRB_LED(ledData, i, 0, 0, 50);\n    neopixel_show_P3_4(ledData, NUM_BYTES);\n    delay(200);\n  }\n\n}\n\n"))),(0,r.kt)("div",{style:{display:"flex",justifyContent:"center"}},(0,r.kt)("video",{autoPlay:!0,muted:!0,loop:!0,src:n(8634).Z})),(0,r.kt)("h2",{id:"easy-touch"},"Easy Touch"),(0,r.kt)("p",null,"A simple example that when a face is touch prints the face that has received input from."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Check the code \ud83d\udda5"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="EasyTouch/EasyTouch.ino"',title:'"EasyTouch/EasyTouch.ino"'},'/*\nEasy Touch\n\nA simple example that when detect a touch of a face prints the face that has received input from\n\ncreated 2022\nby Noteolvides for use with CH55xduino\n\nThis example code is in the public domain.\n*/\n#include <TouchKey.h>\n\n\nenum states {\n  RELEASED,\n  HOLDING,\n  LONG_HOLD,\n};\n\ntypedef struct {\n  uint8_t history;\n  uint16_t downTime;\n} stateBtn;\n\n__xdata stateBtn stateButtons[5];  // Back,Right,Left,Front,Top\nconst char* face[] = {"Back", "Right", "Left", "Front", "Top"};\n\n#define DELAY 10\n#define LOONG_PRESS 2000\n\nvoid setup() {\n  TouchKey_begin((1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) |\n                 (1 << 5));  // Enable all 6 channels: TIN0(P1.0), TIN1(P1.1), TIN2(P1.4),\n                             // TIN3(P1.5), TIN4(P1.6), TIN5(P1.7)\n\n  // In most cases you don\'t need to adjust parameters. But if you do, test with\n  // TouchKeyTuneParameter example\n  /*\n    //refer to AN3891 MPR121 Baseline System for more details\n    TouchKey_SetMaxHalfDelta(5);      //increase if sensor value are more noisy\n    TouchKey_SetNoiseHalfDelta(2);    //If baseline need to adjust at higher rate, increase this\n    value TouchKey_SetNoiseCountLimit(10);  //If baseline need to adjust faster, increase this value\n    TouchKey_SetFilterDelayLimit(5);  //make overall adjustment slopwer\n\n    TouchKey_SetTouchThreshold(100);  //Bigger touch pad can use a bigger value\n    TouchKey_SetReleaseThreshold(80); //Smaller than touch threshold\n  */\n for (uint8_t i = 0; i < 5; i++)\n {\n   stateButtons[i].history = RELEASED;\n   stateButtons[i].downTime = 0;\n }\n\n}\n\nvoid loop() {\n  TouchKey_Process();\n  uint8_t touchResult = TouchKey_Get();\n  for (uint8_t i = 0; i < 5; i++) {\n    switch (stateButtons[i].history) {\n      case RELEASED:  // Not presed before\n        if (!(touchResult & (1 << (i + 1))))\n          break;  // Not touched\n        USBSerial_print_s(face[i]);\n        USBSerial_println_s(" Has been touched");\n        stateButtons[i].history = HOLDING;  // Touch detected\n        stateButtons[i].downTime += DELAY;\n        break;\n      case HOLDING:                       // Touch detected before\n        if (!(touchResult & (1 << i + 1))) {  // Is now relesed\n          USBSerial_print_s(face[i]);\n          USBSerial_println_s(" Has been released");\n          stateButtons[i].downTime = 0;\n          stateButtons[i].history = RELEASED;\n          break;\n        }\n        stateButtons[i].downTime += DELAY;             // Keeep touching\n        if (stateButtons[i].downTime > LOONG_PRESS) {  // A long prees is detected\n          USBSerial_print_s(face[i]);\n          USBSerial_println_s(" it is still being press.");\n          stateButtons[i].downTime = 0;\n          stateButtons[i].history = LONG_HOLD;\n        }\n        break;\n      case LONG_HOLD:\n        if (!(touchResult & (1 << (i + 1)))) {\n          stateButtons[i].history = RELEASED;  // Have to wait to long press is released\n          USBSerial_print_s(face[i]);\n          USBSerial_println_s(" Has been released");\n        }\n        break;\n    }\n    USBSerial_flush();\n  }\n  delay(DELAY);\n}\n\n'))),(0,r.kt)("div",{style:{display:"flex",justifyContent:"center"}},(0,r.kt)("video",{style:{width:"100%"},autoPlay:!0,muted:!0,loop:!0,src:n(7711).Z})),(0,r.kt)("h2",{id:"cdc-and-keyboard"},"CDC and Keyboard"),(0,r.kt)("p",null,"This examples echoes next character of data it receives via the serial monitor."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Check the code \ud83d\udda5"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="CDC_KEYBOARD/CDC_KEYBOARD.ino"',title:'"CDC_KEYBOARD/CDC_KEYBOARD.ino"'},'/*\n  CDC + HID Keyboard\n\n  A simple examples echoes next character of data it receives.\n\n  created 2022\n  by Noteolvides for use with CH55xduino\n\n  This example code is in the public domain.\n*/\n\n\n#ifndef USER_USB_RAM\n#error "This example needs to be compiled with a USER USB setting"\n#error "Tools--\x3e USB Settings--\x3e USER CODE w/148 USB Ram"\n#endif\n\n#include "src/CDC_KEYBOARD/USBCDC.h"\n#include "src/CDC_KEYBOARD/USBHIDKeyboard.h"\n\n\nvoid setup() {\n  USBInit();\n}\n\nvoid loop() {\n\n\n  while (USBSerial_available()) {\n    char serialChar = USBSerial_read();\n    if ((serialChar != \'\\n\') && (serialChar != \'\\r\') ) {\n      USBSerial_print_s("Recived:");\n      USBSerial_println_c(serialChar);\n      USBSerial_print_s("Sending next character....");\n      USBSerial_println_c(serialChar+1);\n      USBSerial_flush();\n      delay(500);\n      Keyboard_write(serialChar+1);\n    }\n  }\n}\n\n'))),(0,r.kt)("div",{className:"margin-bottom--lg",style:{display:"flex",justifyContent:"center"}},(0,r.kt)("video",{style:{width:"100%"},autoPlay:!0,muted:!0,loop:!0,src:n(8639).Z})),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f This example needs to be compiled with a ",(0,r.kt)("strong",{parentName:"p"},"USER USB")," setting\nTools--\x3e USB Settings--\x3e USER CODE w/148 USB Ram")),(0,r.kt)("h2",{id:"custom-bootloader"},"Custom bootloader"),(0,r.kt)("p",null,"This example that shows how to jump to the bootloader address to make it reprogrammable.\nYou can send the character B, or connect the pin 11 to GND."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Check the code \ud83d\udda5"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="CustomBootloader/CustomBootloader.ino"',title:'"CustomBootloader/CustomBootloader.ino"'},"/*\n  Custom Botloader\n\n  A simple example that shows how to jump to the bootloader address to make it reprogrammable.\n  You can send the character B, or connect the pin 11 to GND.\n\n  created 2022\n  by Noteolvides for use with CH55xduino\n\n  This example code is in the public domain.\n*/\n\nvoid jump_to_bootloader() {\n  USB_INT_EN = 0;   // USB interrupt disable\n  USB_CTRL = 0x06;  // USB base control Reset\n  delay(100);\n  EA = 0;                    // Disable all interrupts\n  __asm__(\"lcall #0x3800\");  // Jump to bootloader code\n  while (1);\n}\n\nvoid setup() {\n  pinMode(11, INPUT_PULLUP);\n}\n\nvoid loop() {\n  while (USBSerial_available()) {\n    char serialChar = USBSerial_read();\n    char inputUP = digitalRead(11);\n    if (serialChar == 'B' || inputUP == 0) {\n      jump_to_bootloader();\n    }\n  }\n}\n\n\n"))))}h.isMDXComponent=!0},1333:function(e,t,n){t.Z=n.p+"assets/images/EasyRGB-6b14ed0e25583c7878fe15f634a36cda.png"},8069:function(e,t,n){t.Z=n.p+"assets/images/EasyRGBPhoto-240545df5440c37c89ee39c4b258d230.jpg"},8639:function(e,t,n){t.Z=n.p+"assets/medias/CDC_KEYBOARD-6f56548b97808dcfc8ac14591c6d770a.mp4"},8634:function(e,t,n){t.Z=n.p+"assets/medias/ChaseTest-d40195957a7900d353474fcbe29dccd1.mp4"},7711:function(e,t,n){t.Z=n.p+"assets/medias/EasyTouch-40c89e4baf90548e0f452b633b6157b6.mp4"}}]);